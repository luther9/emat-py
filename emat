#!/usr/bin/env python3

# Copyright 2020-2021 Luther Thompson

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License (GPL3) as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# You have the following additional permission: You may convey the program in
# object code form under the terms of sections 4 and 5 of GPL3 without being
# bound by section 6 of GPL3.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

from argparse import ArgumentParser
from bisect import bisect_left
import cmd
from datetime import date as Date
import functools
from itertools import takewhile
import pickle
import readline
import shlex

# DATABASE REPRESENTATION

# The database is a dict with track names as keys. Each value is a tuple of
# (date, value) pairs. The reason why we represent a track with a tuple instead
# of a dict is because every command that queries a date also requires us to
# look at all previous dates.

argParser = ArgumentParser()
argParser.add_argument(
    'filename',
    help="The filename of the database, not including the '.emat' extention",
)
argParser.add_argument(
    'dayFactor',
    nargs='?',
    default=0.1,
    type=float,
    help="The weight of each amount on its own day's average. Should be between 0 and 1.",
)


# Memoize this function, because it gets called a lot in comprehensions.
@functools.lru_cache()
def maxLen(iterable):
    """Get the maximum length of the items in iterable.

    If the iterable is empty, return None. Due to memoization, the iterable must
    be hashable."""
    return max(map(len, iterable), default=None)


def shlexSplit(arg):
    """Call shlex.split and return the result.

    If it raises a ValueError, print it and return None.
    """
    try:
        return shlex.split(arg)
    except ValueError as e:
        print(e)


def parseGet(arg):
    """Parse arguments for the get command.

    If the arguments are invalid, return None. If no date is given, use the
    current date.
    """
    args = shlexSplit(arg)
    if args is not None:
        name = args[0] if args else ''
        try:
            date = (
                Date.today() if len(args) < 2 else Date.fromisoformat(args[1])
            )
        except ValueError as e:
            print(e)
            return
        return name, date


def findEntry(track, date):
    """Return the index in track where date should be inserted.

    The second element of the return value is True if date already exists in
    track.
    """
    dates = tuple(x[0] for x in track)
    i = bisect_left(dates, date)
    return i, len(dates) > i and dates[i] == date


def showEntry(db, name, date, dayFactor, nameWidth=1):
    """Return a string showing the amount and average for the given name and
    date.
    """
    decay = 1 - dayFactor
    track = db[name]
    i, hasToday = findEntry(track, date)
    todaysAmount = track[i][1] if hasToday else 0
    average = functools.reduce(
        lambda average, entry:
            average + entry[1] * decay**(date - entry[0]).days,
        takewhile(lambda entry: entry[0] <= date, track),
        0,
    ) * dayFactor
    # Use .g format for todaysAmount, because without a format, it shows a
    # gratuitous '.0'.
    return f'{name:{nameWidth}} {date} {todaysAmount:.15g} {average:.5g}'


def findType(lst, cls):
    """Call cls on each element in lst and return the first result that doesn't
    throw a ValueError. If none are successful, return None.
    """
    for x in lst:
        try:
            return cls(x)
        except ValueError:
            pass


def getArgsForSet(db, arg, command):
    """Parse args for 'set' and 'add' commands.

    If arg is invalid, return None. Otherwise, return a (name, date, amount)
    tuple.
    """
    args = shlexSplit(arg)
    if args is None:
        return
    if len(args) not in (2, 3):
        Cmd(None, None, None).do_help(command)
        return
    dateAmount = args[1:]
    date = (
        Date.today()
        if len(dateAmount) < 2
        else findType(dateAmount, Date.fromisoformat)
    )
    if date is None:
        print('No valid date in ', dateAmount)
        return
    amount = findType(dateAmount, float)
    if amount is None:
        print('No valid amount in ', dateAmount)
        return
    name = args[0]
    if not name:
        print("Track name can't be an empty string")
        return
    if name not in db:
        while True:
            answer = input(
                'Are you sure you want to create a new track? [Y/n] ',
            )
            if not answer:
                break
            a = answer[0].lower()
            if a == 'n':
                return
            if a == 'y':
                break
    return name, date, amount


class Cmd(cmd.Cmd):
    """Command methods return either None or True."""
    prompt = '> '

    def __init__(self, db, filename, dayFactor):
        super().__init__()
        self.db = db
        self.filename = filename
        self.dayFactor = dayFactor

    def do_EOF(self, arg):
        """End the program."""
        return True

    def _setEntry(self, name, date, amount):
        """Set the entry with the given name and date to the amount."""
        track = self.db.get(name, ())
        i, exists = findEntry(track, date)
        track_ = (
            track[:i]
            + (((date, amount),) if amount else ())
            + track[i + exists :]
        )
        self.db = dict(
            {k: v for k, v in self.db.items() if k != name},
            **{name: track_} if track_ else {},
        )
        print(showEntry(self.db, name, date, self.dayFactor))

    def do_set(self, arg):
        """set <name> <date> <amount>

        Create a database entry. If there is already an entry with the same name
        and date, overwrite the amount. If there are no existing entries with
        the same name, get confirmation to create a new track.
        """
        args = getArgsForSet(self.db, arg, 'set')
        if args:
            self._setEntry(*args)

    def do_add(self, arg):
        """add <name> <date> <amount>

        Like `set`, but adds the given amount to the current amount to get the
        new amount.
        """
        args = getArgsForSet(self.db, arg, 'add')
        if args:
            name, date, amount = args
            if name not in self.db:
                oldAmount = 0
            else:
                track = self.db[name]
                i, exists = findEntry(track, date)
                oldAmount = track[i][1] if exists else 0
            self._setEntry(name, date, oldAmount + amount)

    def do_get(self, arg):
        """get <name> <date>

        Show the amount and moving average for the given date. If the name is
        the empty string (the default), show a result for every name in the
        database.
        """
        args = parseGet(arg)
        if args:
            name, date = args
            def showData(name, nameWidth=1):
                return showEntry(self.db, name, date, self.dayFactor, nameWidth)
            names = tuple(sorted(self.db))
            print(
                '\n'.join(
                    showData(thisName, maxLen(names)) for thisName in names
                )
                if not name
                else showData(name)
                if name in self.db
                else name + ' is not in the database.',
            )

    def do_list(self, arg):
        """list <name>

        List all entries with a non-zero amount for the given name. Include the
        moving averages. If no name is given, list all entries. Results are
        sorted by name, then date.
        """
        def listData(name, nameWidth=1):
            return '\n'.join(
                showEntry(self.db, name, entry[0], self.dayFactor, nameWidth)
                for entry in self.db[name]
            )
        if arg:
            args = shlexSplit(arg)
            if args:
                name = args[0]
                print(
                    listData(name)
                    if name in self.db
                    else name + ' is not in the database.',
                )
        else:
            names = tuple(sorted(self.db))
            print('\n'.join(listData(name, maxLen(names)) for name in names))

    def do_save(self, arg):
        """Save the database."""
        with open(self.filename, 'wb') as f:
            pickle.dump(self.db, f)

    def completedefault(self, text, line, begidx, endidx):
        """Auto-complete the track names."""
        # The following facts about this callback are not documented:
        # text is the current stretch of non-whitespace. Quote marks seem to be
        # handled in some "smart" way that I can't determine.
        # We must return an indexable sequence, not an iterator.
        return tuple(name for name in self.db if name.startswith(text))


def main(args):
    filename = args.filename + '.emat'

    try:
        with open(filename, 'rb') as f:
            db = pickle.load(f)
    except FileNotFoundError:
        db = {}

    Cmd(db, filename, args.dayFactor).cmdloop()
    print()


if __name__ == '__main__':
    main(argParser.parse_args())
